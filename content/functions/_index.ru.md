+++
title = "Функции"
archetype = "default"
url = "functions"
weight = 10
+++

## Функции
<gray>Жопа с функцией чайник</gray>

<hundred-empty-line></hundred-empty-line>

Функции есть в практически любом языке программирования, они используются для того чтобы программист не переписывал одинаковые фрагменты кода, которые постоянно используются. От них вы не получите повышенной скорости выполнения кода, или иные технические бонусы, но это повысит скорость и удобство разработки. Синтакс функций в Skript выглядит следующим образом:
<fifty-empty-line></fifty-empty-line>
Функция без возвращаемых данных:
```
function НазваниеФункции(Список параметров):
  #ваш код
```
Функция с возратом каких-либо данных:
```
function НазваниеФункции(Список параметров) :: ТипВозвращаемогоЗначения:
  #ваш код
```
Где список параметров - это та информация, которая поступает в нее, базовый вариант для обозначения параметров это:
```
function НазваниеФункции(parameter1: ТипДанных,parameter2: ТипДанных...):
  #ваш код
```
Где ТипДанных - это какой тип информации может получить эта функция 
Кроме этого, можно указать стандартное значение для какого-либо параметра.
```
function НазваниеФункции(parameter1: number,parameter2: number=10):
  #ваш код
```
В таком случае, при вызове функции параметр 2 можно не указывать, он самостоятельно примет значение 10.
Параметров может быть любое количество, а может не быть вовсе:
```
function НазваниеФункции():
  #ваш код
```
или
```
function НазваниеФункции() :: ТипВозвращаемогоЗначения:
  #ваш код
```
Параметры внутри блока функции будут являться локальными переменными, существующие только внутри этой функции, например если есть параметр msg: text, то внутри функции значение из этого параметра будет храниться в локальной переменной {\_msg}
Функции позволяют нам передавать в одном параметре множество значений, а также возвращать множество значений:
```
function НазваниеФункции(parameter1: numbers,parameter2: numbers) :: numbers:
  #ваш код
```
Возвращаемый список данных возвращается c нумерными индексами от единицы до кол-ва элементов.
Чтобы передать список литералов в параметр - используйте скобки:
`myFunc((1,2,3,4,5),"text")`
Функции как глобальные переменные - можно использовать внутри любого скрипта, но она обязательно должна быть определена раньше чем место, где мы будем ее использовать, лучший вариант - создать отдельный файл с функциями, чтобы он по алфавиту был раньше чем файлы с кодом, тогда проблем возникать не будет.
Теперь узнаем как использовать написанные функции в коде:
У нас есть вот такая определенная в коде функция:
```
function sendMSG(player: player, msg: text):
  send {_msg} to {_player}
```
Она банально отправляет текст из параметра 2, игроку в параметре 1\
Применение:
```
on break:
  sendMSG(player,"Вы сломали блок")
При разрушении блока игроку отправится сообщение: Вы сломали блок
Теперь поработаем с параметром, который может принимать список значений, изменим нашу функцию:
function sendMSG(player: player, msg: texts):
  loop {_msg::*}:
    send loop-value to {_player}
```
В данном случае второй аргумент, так как он указан типом texts будет списком со значениями\
Применение:
```
on break:
  sendMSG(player,("Вы сломали блок","сломайте еще блок"))
Или, аналогичный код без использования литералов в аргументах:
on break:
  set {_text::1} to "Вы сломали блок"
  set {_text::2} to "сломайте еще блок"
  sendMSG(player,{_text::*})
```
Теперь попробуем написать функцию с каким-либо возвращаемым значением, например функцию для получения куба числа:
```
function cubeNumber(value: number) :: number:
  return {_value}*{_value}*{_value}
```
Здесь используется ключевое выражение return %objects% позволяющее нам вернуть результат\
Причем код, который будет следовать после выполнения этой строки - не выполнится, в более сложном смысле подпрограмма (функция) передаст управление основному коду, из которого она была вызвана\
Применение:
```
on load:
  set {_cube} to cubeNumber(128)
```
в переменную {\_cube} будет записано число 2097152\
Нельзя использовать wait/delay внутри функции с возвратом.\
Функции без возвращаемых данных выполняются асинхронно, в отдельном потоке, то есть:
```
function HelloWorld():
  wait 5 seconds
  broadcast "Hello World!"
on load:
  HelloWorld()
  broadcast "This message first"
```
Сначала будет выведено 'This message first', затем (через 5 секунд) 'Hello World!'